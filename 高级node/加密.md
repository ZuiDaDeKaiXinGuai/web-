#### crypto
`crypto`模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过`cypto`这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。

#### 单向加密

- 没有办法解密，规则公开之后也不能解密。
- 任何时刻加密的结果一样（存储的是加密之后）

> MD5和SHA1
```
const crypto = require('crypto');

const hash = crypto.createHash('md5');

// 可任意多次调用update():
hash.update('Hello, world!');
hash.update('Hello, nodejs!');

console.log(hash.digest('hex')); 
//hex 十六进制
//base64 64个可打印字符来表示二进制数据的方法
//latin1 编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是控制字符，0xA0-0xFF之间是文字符号
// 7e1977739c748beac0c0fd14fd26a544
```
`update()`方法默认字符串编码为`UTF-8`，也可以传入`Buffer`

如果要计算SHA1，只需要把`md5`改成`sha1`，就可以得到`SHA1`的结果1f32b9c9932c02227819a4151feed43e131aca40。

还可以使用更安全的`sha256`和`sha512`。

> Hmac

Hmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥
```
const crypto = require('crypto');

const hmac = crypto.createHmac('sha256', 'secret-key');

hmac.update('Hello, world!');
hmac.update('Hello, nodejs!');

console.log(hmac.digest('hex')); // 80f7e22570...
```

只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。


----

#### 双向加密

##### 1. 对称加密（加密解密用到密钥一样的）

> AES

AES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持

```
const cipher = crypto.createCipher('aes192', key密钥)
```
创建加密对象。 `aes192` `aes-128-ecb` `aes-256-cbc` 等，AES除了密钥外还可以指定IV（Initial Vector），不同的系统只要IV不同，用相同的密钥加密相同的数据得到的加密结果也是不同的。

```
cipher.update(data, 'utf8', 'hex');
```
加密对象签名
- data 要加密的数据
- 'utf8'要加密的数据格式
- 'hex'加密算法
- 返回值:字符串

```
cipher.final('hex')
```
返回任何加密的内容。一旦cipher.final()方法已被调用， Cipher 对象就不能再用于加密数据

```
const decipher = crypto.createDecipher('aes192', key密钥)
```
创建解密对象

```
decipher.update(encrypted, 'hex', 'utf8');
```
解密对象签名
- encrypted 要解密的数据
- 'hex'要解密的数据格式
- 'utf8'解密之后的数据格式
- 返回值:字符串

```
decipher.final('utf8');
```
返回任何加密的内容。一旦cipher.final()方法已被调用， Cipher 对象就不能再用于加密数据


##### 2. 非对称加密（公钥-》私钥 私钥-》公钥）

> RSA

RSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。

RSA算法是1977年由Ron Rivest、Adi Shamir和Leonard Adleman共同提出的，所以以他们三人的姓氏的头字母命名。

当小明给小红发送信息时，可以用小明自己的私钥加密，小红用小明的公钥解密，也可以用小红的公钥加密，小红用她自己的私钥解密，这就是非对称加密。相比对称加密，非对称加密只需要每个人各自持有自己的私钥，同时公开自己的公钥，不需要像AES那样由两个人共享同一个密钥。

1. 准备好私钥和公钥 

```
openssl genrsa -aes256 -out rsa-key.pem 2048
```

根据提示输入密码，这个密码是用来加密RSA密钥的，加密方式指定为AES256，生成的RSA的密钥长度是2048位。执行成功后，我们获得了加密的`rsa-key.pem`文件

2. 通过rsa-key.pem加密文件，导出原始的私钥

```
openssl rsa -in rsa-key.pem -outform PEM -out rsa-prv.pem
```

通过以下命令可以导出原始公钥

```
openssl rsa -in rsa-key.pem -outform PEM -pubout -out rsa-pub.pem
```

准备好了原始私钥文件`rsa-prv.pem`和原始公钥文件`rsa-pub.pem`，编码格式均为PEM。

3. 私钥加密，公钥解密 或者 公钥加密，私钥解密

```
//prvKey 读取rsa-prv.pem 字符串
crypto.privateEncrypt(prvKey, Buffer.from('要加密的信息', 'utf8'));
```
私钥加密

```
//pubKey 读取rsa-pub.pem 字符串
crypto.publicDecrypt(pubKey, 私钥加密的返回值);
```
公钥解密


```
crypto.publicEncrypt(pubKey, Buffer.from('要加密的信息', 'utf8'));
```
公钥加密

```
crypto.privateDecrypt(prvKey, 公钥加密的返回值);
```
私钥解密

